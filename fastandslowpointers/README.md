# Linked List Cycle

Check whether or not a linked list contains a cycle. If a cycle exists, return TRUE. Otherwise, return FALSE. The cycle means that at least one node can be reached again by traversing the next pointer.

# Palindrome Linked List

Given the head of a linked list, your task is to check whether the linked list is a palindrome or not. Return TRUE if the linked list is a palindrome; otherwise, return FALSE.

# Maximum Twin Sum of a Linked List

In a linked list of even length `n`, the node at position `i` (using 0-based indexing) is considered the **twin** of the node at position `(n - 1 - i)`, for all `0 ≤ i < n / 2`.

## Example

If `n = 4`:
- Node `0` and node `3` are twins.
- Node `1` and node `2` are twins.

These are the only twin pairs in a linked list of size 4.
The **twin sum** is defined as the sum of a node’s value and its twin’s value.
Given the head of a linked list with an even number of nodes, return the **maximum twin sum** of the linked list.

### Find the duplicate number

Given an array of positive numbers, nums, such that the values lie in the range [1,n], inclusive, and that there are n+1 numbers in the array, find and return the duplicate number present in nums. There is only one repeated number in nums.

### Middle of the linked list

Given the head of a singly linked list, return the middle node of the linked list. If the number of nodes in the linked list is even, there will be two middle nodes, so return the second one.

### Happy Number

Start with the given number n.
Repeat the following process:
Replace n with the sum of the squares of its digits.
Continue this process until one of two things happens:
The number becomes 1, which indicates that the number is a happy number.
The number enters a cycle, indicating the number is not a happy number (this means you will eventually revisit a previously seen number).
Return TRUE if n is a happy number, otherwise return FALSE.



